// Generated by CoffeeScript 1.7.1
(function() {
  define(['parse', 'utility'], function(parse, utility) {
    var arg_list, arith, call, compare, compile, compile_blocks, compile_blocks_with_return, compile_suite, cond, def, do_loop, func_and_args, if_statement, lambda, let_statement, set_statement;
    def = function(src) {
      var args, params, suite;
      suite = parse.blocks(src);
      args = suite.splice(0, 1).pop();
      if (parse.is_function(src)) {
        params = parse.blocks(utility.clean_up(args));
        return "function " + func_and_args(params) + ' {\n' + compile_blocks_with_return(suite) + '}\n';
      } else {
        return 'var ' + blocks[0] + ' = ' + compile(suite) + ';\n';
      }
    };
    call = function(src) {
      return func_and_args(parse.blocks(utility.clean_up(src)));
    };
    arith = function(op, args) {
      var arg, lastarg, text, _i, _len, _ref;
      args = parse.blocks(args);
      lastarg = args[args.length - 1];
      text = '(';
      _ref = args.splice(0, args.length - 1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        arg = _ref[_i];
        text += compile(arg) + ' ' + op + ' ';
      }
      return text + compile(lastarg) + ')';
    };
    compare = function(op, args) {
      var blocks, i, text, _i, _ref;
      blocks = parse.blocks(args.trim());
      if (blocks.length > 2) {
        text = '(and ';
        for (i = _i = 0, _ref = blocks.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          text += '(' + op + ' ' + blocks[i] + ' ' + blocks[i + 1] + ') ';
        }
        return compile(text + ')');
      } else {
        return arith(op, args);
      }
    };
    if_statement = function(src) {
      var blocks;
      blocks = parse.blocks(src.trim());
      return "(" + compile(blocks[0]) + "? " + compile(blocks[1]) + " : " + compile(blocks[2]) + ")";
    };
    arg_list = function(args) {
      var x;
      return parse.arg_list_verb((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i < _len; _i++) {
          x = args[_i];
          _results.push(compile(x));
        }
        return _results;
      })());
    };
    func_and_args = function(args) {
      if (parse.is_function(args[0])) {
        args[0] = '(' + compile(args[0]) + ')';
      }
      return args[0] + arg_list(args.splice(1, args.length - 1));
    };
    cond = function(src) {
      var block, blocks, pred, suite, text, _i, _len;
      blocks = parse.blocks(src.trim());
      text = "(function() {\n";
      for (_i = 0, _len = blocks.length; _i < _len; _i++) {
        block = blocks[_i];
        suite = parse.blocks(utility.clean_up(block));
        pred = suite.splice(0, 1).pop();
        if (block !== blocks[0]) {
          text = text + "} else ";
        }
        if (pred !== "else" && pred !== "#t") {
          text = text + "if (" + compile(pred) + ") ";
        }
        text += "{\n" + compile_blocks_with_return(suite);
      }
      return text + "}\n})()";
    };
    lambda = function(src) {
      var args, blocks, suite;
      blocks = parse.blocks(src.trim());
      args = parse.blocks(utility.clean_up(blocks[0]));
      suite = blocks[1].trim();
      args.splice(0, 0, 'function');
      return func_and_args(args) + ' {\nreturn ' + compile(suite) + ';\n}\n';
    };
    let_statement = function(src, star) {
      var a, bind, bindings, code_1, code_2, code_3, i, is_last, suite, temp_var, x, _i, _len, _ref, _ref1;
      suite = utility.clean_up(parse.blocks(src));
      bindings = parse.blocks(blocks.splice(0, 1));
      _ref = ['var ', '', '', 0, 'temp'], code_1 = _ref[0], code_2 = _ref[1], code_3 = _ref[2], i = _ref[3], temp_var = _ref[4];
      for (_i = 0, _len = bindings.length; _i < _len; _i++) {
        bind = bindings[_i];
        is_last = bind === utility.last(bindings);
        _ref1 = parse.blocks(utility.strip_outer_parentheses(bind.trim())), x = _ref1[0], a = _ref1[1];
        code_1 += x + (is_last ? ';\n' : ', ');
        if (star) {
          code_3 += x + ' = ' + compile(a) + ';\n';
        } else {
          code_2 += compile(a) + (is_last ? '];\n' : ', ');
          code_3 += x + ' = !@#$%[' + i + (is_last ? '];\n' : '], ');
        }
        i += 1;
        while (x.indexOf(temp_var) !== -1) {
          temp_var = '_' + temp_var;
        }
      }
      if (!star) {
        code_2 = 'var ' + temp_var + ' = [' + code_2;
      }
      code_3 = utility.replace_all(code_3, '!@#$%', temp_var);
      return parse.anon_wrap(code_1 + code_2 + code_3 + 'return ' + compile(suite));
    };
    set_statement = function(src) {
      var blocks;
      blocks = parse.blocks(src.trim());
      return blocks[0] + ' = ' + compile(blocks[1].trim());
    };
    do_loop = function(src) {
      var bindings, clause, init, name, return_expression, step, suite, test, text, update, value, x, y, _i, _len, _ref, _ref1, _ref2, _ref3;
      _ref = parse.blocks(src.trim()), bindings = _ref[0], clause = _ref[1], suite = _ref[2];
      _ref1 = [parse.blocks(utility.clean_up(bindings)), [], []], bindings = _ref1[0], init = _ref1[1], update = _ref1[2];
      y = parse.separate(clause.trim());
      y.push('undefined');
      _ref2 = [y[0], y[1]], test = _ref2[0], return_expression = _ref2[1];
      for (_i = 0, _len = bindings.length; _i < _len; _i++) {
        x = bindings[_i];
        _ref3 = parse.blocks(utility.clean_up(x)), name = _ref3[0], value = _ref3[1], step = _ref3[2];
        init.push(name + ' = ' + compile(value));
        update.push(name + ' = ' + compile(step));
      }
      init[0] = 'var ' + init[0];
      text = "for(" + utility.strip_outer_parentheses(parse.arg_list_verb(init)) + "; ";
      text += "!(" + compile(test) + "); ";
      text += utility.strip_outer_parentheses(parse.arg_list_verb(update)) + ") {\n";
      text += compile(suite) + "}\nreturn " + compile(return_expression) + ";\n";
      return parse.anon_wrap(text);
    };
    compile = function(src) {
      var first, n, rest, _ref;
      src = utility.clean_up(src);
      n = utility.find_end(src);
      if (n === src.length - 1) {
        switch (src) {
          case "#t":
            return "true";
          case "#f":
            return "false";
          default:
            return src;
        }
      } else {
        _ref = [src.substring(0, n + 1), src.substring(n + 1).trim()], first = _ref[0], rest = _ref[1];
        switch (first) {
          case "define":
            return def(rest);
          case "*":
          case "+":
          case "-":
            return arith(first, rest);
          case "and":
            return arith('&&', rest);
          case "or":
            return arith('||', rest);
          case "not":
            return '!' + compile(rest);
          case "<":
          case ">":
          case ">=":
          case "<=":
            return compare(first, rest);
          case "=":
          case "==":
            return compare("==", rest);
          case "if":
            return if_statement(rest);
          case "cond":
            return cond(rest);
          case "lambda":
            return lambda(rest);
          case "let":
            return let_statement(rest, false);
          case "let*":
            return let_statement(rest, true);
          case "set!":
            return set_statement(rest);
          case "do":
            return do_loop(rest);
          default:
            return call(src);
        }
      }
    };
    compile_blocks_with_return = function(blocks) {
      var last_block;
      last_block = blocks.pop();
      return compile_blocks(blocks) + 'return ' + compile(last_block) + ';\n';
    };
    compile_blocks = function(blocks) {
      var block, code, _i, _len;
      code = "";
      for (_i = 0, _len = blocks.length; _i < _len; _i++) {
        block = blocks[_i];
        code += utility.add_semicolon(compile(block));
      }
      return code;
    };
    return compile_suite = function(src) {
      return compile_blocks(parse.blocks(src));
    };
  });

}).call(this);
