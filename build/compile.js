// Generated by CoffeeScript 1.7.1

/* file:   compile.coffee
    made:   5/31/2014
    note:   definition / support for the compile(string) function
 */

(function() {
  var arith, call, compare, compile, compile_blocks, compile_blocks_with_return, compile_suite, cond, define, do_loop, if_statement, lambda, let_statement, set_statement;

  define = function(src) {

    /* Takes "(define (f x_1 ... x_n) (stuffs))" and gives "function f(x_1, ..., x_n)
        { return stuffs; }", or takes "(define x 3)" and gives "var x = 3;".
     */
    var args, params, suite;
    suite = parse.blocks(src);
    args = suite.splice(0, 1).pop();
    if (parse.is_function(src)) {
      params = parse.blocks(util.clean_up(args));
      return "function " + parse.func_and_args(params) + ' {\n' + compile_blocks_with_return(suite) + '}\n';
    } else {
      return 'var ' + blocks[0] + ' = ' + compile(suite) + ';\n';
    }
  };

  call = function(src) {

    /* Takes something like "(f x_1 ... x_n)". */
    return parse.func_and_args(parse.blocks(util.clean_up(src)));
  };

  arith = function(op, args) {

    /* Handles the case of (* x_1 ... x_n), etc. */
    var arg, lastarg, text, _i, _len, _ref;
    args = parse.blocks(args);
    lastarg = args[args.length - 1];
    text = '(';
    _ref = args.splice(0, args.length - 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      arg = _ref[_i];
      text += compile(arg) + ' ' + op + ' ';
    }
    return text + compile(lastarg) + ')';
  };

  compare = function(op, args) {

    /* Turns '(<= x_1 ... x_n)' into '(x_1 <= x_2) && ... && (x_{n-1} <= x_n)'. */
    var blocks, i, text, _i, _ref;
    blocks = parse.blocks(args.trim());
    if (blocks.length > 2) {
      text = '(and ';
      for (i = _i = 0, _ref = blocks.length - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        text += '(' + op + ' ' + blocks[i] + ' ' + blocks[i + 1] + ') ';
      }
      return compile(text + ')');
    } else {
      return arith(op, args);
    }
  };

  if_statement = function(src) {

    /* Takes '(if x y z)' and gives 'x? y : z'. */
    var blocks;
    blocks = parse.blocks(src.trim());
    return "(" + compile(blocks[0]) + "? " + compile(blocks[1]) + " : " + compile(blocks[2]) + ")";
  };

  cond = function(src) {

    /* Takes '(cond (a b) ... (c d))' and gives an equivalent if/else,
        wrapped in an anonymous function.
     */
    var block, blocks, pred, suite, text, _i, _len;
    blocks = parse.blocks(src.trim());
    text = "(function() {\n";
    for (_i = 0, _len = blocks.length; _i < _len; _i++) {
      block = blocks[_i];
      suite = parse.blocks(util.clean_up(block));
      pred = suite.splice(0, 1).pop();
      if (block !== blocks[0]) {
        text = text + "} else ";
      }
      if (pred !== "else" && pred !== "#t") {
        text = text + "if (" + compile(pred) + ") ";
      }
      text += "{\n" + compile_blocks_with_return(suite);
    }
    return text + "}\n})()";
  };

  lambda = function(src) {

    /* Takes '(x ... z) (suite)' and gives a lambda, i.e. anonymous js
        function 'function(x, ..., z) { compile(suite); }'.
     */
    var args, blocks, suite;
    blocks = parse.blocks(src.trim());
    args = parse.blocks(util.clean_up(blocks[0]));
    suite = blocks[1].trim();
    args.splice(0, 0, 'function');
    return parse.func_and_args(args) + ' {\nreturn ' + compile(suite) + ';\n}\n';
  };

  let_statement = function(src, star) {

    /* Takes '((x a)) (suite)' and gives the result of compile applied to
        '((lambda (x) (suite)) a)'.
     */
    var a, bind, bindings, code_1, code_2, code_3, i, is_last, suite, temp_var, x, _i, _len, _ref, _ref1;
    suite = util.clean_up(parse.blocks(src));
    bindings = parse.blocks(blocks.splice(0, 1));
    _ref = ['var ', '', '', 0, 'temp'], code_1 = _ref[0], code_2 = _ref[1], code_3 = _ref[2], i = _ref[3], temp_var = _ref[4];
    for (_i = 0, _len = bindings.length; _i < _len; _i++) {
      bind = bindings[_i];
      is_last = bind === util.last(bindings);
      _ref1 = parse.blocks(util.strip_outer_parentheses(bind.trim())), x = _ref1[0], a = _ref1[1];
      code_1 += x + (is_last ? ';\n' : ', ');
      if (star) {
        code_3 += x + ' = ' + compile(a) + ';\n';
      } else {
        code_2 += compile(a) + (is_last ? '];\n' : ', ');
        code_3 += x + ' = !@#$%[' + i + (is_last ? '];\n' : '], ');
      }
      i += 1;
      while (x.indexOf(temp_var) !== -1) {
        temp_var = '_' + temp_var;
      }
    }
    if (!star) {
      code_2 = 'var ' + temp_var + ' = [' + code_2;
    }
    code_3 = util.replace_all(code_3, '!@#$%', temp_var);
    return parse.anon_wrap(code_1 + code_2 + code_3 + 'return ' + compile(suite));
  };

  set_statement = function(src) {

    /* Takes '(x a)' and gives 'x = a'. */
    var blocks;
    blocks = parse.blocks(src.trim());
    return blocks[0] + ' = ' + compile(blocks[1].trim());
  };

  do_loop = function(src) {

    /* It's complicated... */
    var bindings, clause, init, name, return_expression, step, suite, test, text, update, value, x, y, _i, _len, _ref, _ref1, _ref2, _ref3;
    _ref = parse.blocks(src.trim()), bindings = _ref[0], clause = _ref[1], suite = _ref[2];
    _ref1 = [parse.blocks(util.clean_up(bindings)), [], []], bindings = _ref1[0], init = _ref1[1], update = _ref1[2];
    y = parse.separate(clause.trim());
    y.push('undefined');
    _ref2 = [y[0], y[1]], test = _ref2[0], return_expression = _ref2[1];
    for (_i = 0, _len = bindings.length; _i < _len; _i++) {
      x = bindings[_i];
      _ref3 = parse.blocks(util.clean_up(x)), name = _ref3[0], value = _ref3[1], step = _ref3[2];
      init.push(name + ' = ' + compile(value));
      update.push(name + ' = ' + compile(step));
    }
    init[0] = 'var ' + init[0];
    text = "for(" + util.strip_outer_parentheses(parse.arg_list_verb(init)) + "; ";
    text += "!(" + compile(test) + "); ";
    text += util.strip_outer_parentheses(parse.arg_list_verb(update)) + ") {\n";
    text += compile(suite) + "}\nreturn " + compile(return_expression) + ";\n";
    return parse.anon_wrap(text);
  };

  compile = function(src) {

    /* The main compiling function. */
    var first, n, rest, _ref;
    src = util.clean_up(src);
    n = parse.find_end(src);
    if (n === src.length - 1) {
      switch (src) {
        case "#t":
          return "true";
        case "#f":
          return "false";
        default:
          return src;
      }
    } else {
      _ref = [src.substring(0, n + 1), src.substring(n + 1).trim()], first = _ref[0], rest = _ref[1];
      switch (first) {
        case "define":
          return define(rest);
        case "*":
        case "+":
        case "-":
          return arith(first, rest);
        case "and":
          return arith('&&', rest);
        case "or":
          return arith('||', rest);
        case "<":
        case ">":
        case ">=":
        case "<=":
          return compare(first, rest);
        case "=":
        case "==":
          return compare("==", rest);
        case "if":
          return if_statement(rest);
        case "cond":
          return cond(rest);
        case "lambda":
          return lambda(rest);
        case "let":
          return let_statement(rest, false);
        case "let*":
          return let_statement(rest, true);
        case "set!":
          return set_statement(rest);
        case "do":
          return do_loop(rest);
        default:
          return call(src);
      }
    }
  };

  compile_blocks_with_return = function(blocks) {

    /* Compiles a list of functions, with a return statement on the last. */
    var last_block;
    last_block = blocks.pop();
    return compile_blocks(blocks) + 'return ' + compile(last_block) + ';\n';
  };

  compile_blocks = function(blocks) {

    /* Takes a list of blocks and compiles each one. */
    var block, code, _i, _len;
    code = "";
    for (_i = 0, _len = blocks.length; _i < _len; _i++) {
      block = blocks[_i];
      code += util.add_semicolon(compile(block));
    }
    return code;
  };

  compile_suite = function(src) {

    /* Compiles multiple line programs. */
    return compile_blocks(parse.blocks(src));
  };

  window.compile = compile;

  window.compile_suite = compile_suite;

}).call(this);
